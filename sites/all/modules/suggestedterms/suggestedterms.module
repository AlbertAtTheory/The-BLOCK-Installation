<?php

/*
 * @file
 * Module that displays terms and uses javascript to allow click-adding to
 * taxonomy autocomplete fields.
 */

/*
 * Implements hook_init().
 * Drupal_add_js() was moved into this function to prevent a conflict with CCK Filefield.
 */
function suggestedterms_init() {
  $path = drupal_get_path('module', 'suggestedterms');
  drupal_add_js($path . '/suggestedterms.js', array('type' => 'file', 'scope' => 'header', 'defer' => TRUE, 'weight' => 'JS_DEFAULT'));
  drupal_add_css($path . '/suggestedterms.css', array('type' => 'module', 'media' => 'all', 'preprocess' => TRUE));
}

/**
* define constants
*/
define('SUGGESTEDTERMS_SORT_POPULAR', 0);
define('SUGGESTEDTERMS_SORT_NAME', 1);
define('SUGGESTEDTERMS_SORT_RECENT', 2);
define('SUGGESTEDTERMS_SORT_WEIGHT', 3);
define('SUGGESTEDTERMS_SORT_USED', 4);

define('SUGGESTEDTERMS_DISPLAY_ALL', 1);
define('SUGGESTEDTERMS_DISPLAY_USED', 2);

define('SUGGESTEDTERMS_DISPLAY_FIELDSET', 0);

/**
 * Implementation of hook_help().
 */
function suggestedterms_help($path, $args) {
  $output = '';

  switch ($path) {
    case "admin/help#suggestedterms":
      $output = '<p>' . t("Replaces the default \'description\' text on free-tagging textfields on node edit pages with a list of taxonomy terms in that vocabulary, with appropriate labeling") . '</p>';
      break;
  }

  return $output;
}

/**
 * Implementation of hook_permission().
 */
function suggestedterms_permission() {
  return array(
    'administer suggested terms' => array(
      'title' => t('Administer suggested terms'),
      'description' => t('User can adjust settings such as how to sort the suggested terms.'),
    )
  );
}

/**
 * Implementation of hook_theme().
 */
function suggestedterms_theme() {
  return array(
    'suggestedterm' => array(
      'arguments' => array('name' => NULL),
    ),
  );
}

/**
 * Build tags for each term.
 *
 * @ingroup themeable
 * @param $name
 *   The term name to theme.
 */
function theme_suggestedterm($variables) {
  $name = $variables['name'];
  $selected = $variables['selected'];
  if (FALSE !== strpos($name, ',')) {
    $name = '"' . $name . '"';
  }
  if ($selected) {
    return "<span class='suggestedterm remove'>{$name}</span>";
  }
  else {
    return "<span class='suggestedterm'>{$name}</span>";
  }
}

/**
* Creates all spans from vocabulary terms
*
* @return
*   A string containing the clickable spans for the suggestedterms module.
*/
function _suggestedterms_build_suggestions($vid, $sort_order, $display_what, $selected_terms) {
  // Use left join to display all entries, inner join to diaplay only used ones.
  $query_type = ($display_what == SUGGESTEDTERMS_DISPLAY_ALL) ? " LEFT " : " INNER ";

  // Get max number of terms set by admin.
  $total_terms = array(
    0 => variable_get('suggestedterms_maximum_displayed', 5),
  );

  // Get sort order set by admin.
  switch ($sort_order) {
    case SUGGESTEDTERMS_SORT_POPULAR:
      $query = db_select('taxonomy_term_data', 't');
      $query->fields('t', array('name'));
      $query->condition('t.vid', $vid, '=');
      if ($query_type == ' INNER ') {
        $query->innerJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      elseif ($query_type = ' LEFT ') {
        $query->leftJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      else {
        debug('Join type should be LEFT or INNER, but something else got passed instead.');
      }
      $query->addExpression('COUNT(t.name)', 'total');
      $query->groupBy('t.name');
      $query->orderBy('total', 'DESC');
      if ($total_terms[0] >= 1) {
        $query->range(0, $total_terms[0]);
      }
      //$query = "SELECT t.name AS name, COUNT(t.name) AS total FROM {taxonomy_term_data} t $query_type JOIN {taxonomy_index} tn ON (t.tid = tn.tid) WHERE t.vid = %d GROUP BY t.name ORDER BY total desc";
      break;

    case SUGGESTEDTERMS_SORT_RECENT:
      // List all the terms in the specified vocabulary and sort by term ID (We assume larger numbers were added more recently).
      $query = db_select('taxonomy_term_data', 't');
      $query->fields('t', array('name'));
      $query->groupBy('t.name');
      $query->orderBy('t.tid', 'DESC');
      $query->condition('t.vid', $vid, '=');
      if ($query_type == ' INNER ') {
        $query->innerJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      elseif ($query_type = ' LEFT ') {
        $query->leftJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      else {
        debug('Join type should be LEFT or INNER, but something else got passed instead.');
      }
      if ($total_terms[0] >= 1) {
        $query->range(0, $total_terms[0]);
      }      //$query = "SELECT t.name AS name FROM {taxonomy_term_data} t $query_type JOIN {taxonomy_index} tn ON (t.tid = tn.tid) WHERE t.vid = %d GROUP BY t.name ORDER BY t.tid desc";
      break;

    case SUGGESTEDTERMS_SORT_WEIGHT:
      // List all the terms in the specified vocabulary and sort by term weight.
      $query = db_select('taxonomy_term_data', 't');
      $query->fields('t', array('name'));
      $query->condition('t.vid', $vid, '=');
      if ($query_type == ' INNER ') {
        $query->innerJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      elseif ($query_type = ' LEFT ') {
        $query->leftJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      else {
        debug('Join type should be LEFT or INNER, but something else got passed instead.');
      }
      $query->groupBy('name');
      $query->orderBy('weight', 'ASC');
      $query->orderBy('name');
      if ($total_terms[0] >= 1) {
        $query->range(0, $total_terms[0]);
      }      //$query = "SELECT t.name AS name, t.weight AS weight FROM {taxonomy_term_data} t $query_type JOIN {taxonomy_index} tn ON (t.tid = tn.tid) WHERE t.vid = %d GROUP BY t.name ORDER BY weight, name";
      break;

    case SUGGESTEDTERMS_SORT_USED:
      // List all the terms in the specified vocabulary that are used on nodes. Order by the date the node was last changed.
      $query = db_select('taxonomy_term_data', 't');
      $query->fields('t', array('name', 'tid'));
      $query->condition('t.vid', $vid, '=');
      if ($query_type == ' INNER ') {
        $query->innerJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
        $query->innerJoin('node', 'n', 'ti.nid = n.nid');
      }
      elseif ($query_type = ' LEFT ') {
        $query->leftJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
        $query->leftJoin('node', 'n', 'ti.nid = n.nid');
      }
      else {
        debug('Join type should be LEFT or INNER, but something else got passed instead.');
      }
      $query->orderBy('n.changed', 'DESC');
      $query->orderBy('name', 'ASC');
      $query->distinct();
      if ($total_terms[0] >= 1) {
        $query->range(0, $total_terms[0]);
      }      //$query = "SELECT DISTINCT t.name AS name FROM {taxonomy_term_data} t $query_type JOIN {taxonomy_index} tn ON (t.tid = tn.tid) $query_type JOIN {node} n ON (tn.nid = n.nid) WHERE t.vid = %d ORDER BY n.changed DESC, name";
      break;

    default:
      // List all the term names in the specified vocabulary and order alphabetically.
      $query = db_select('taxonomy_term_data', 't');
      $query->fields('t', array('name', 'tid'));
      $query->groupBy('t.name');
      $query->orderBy('t.name');
      $query->condition('t.vid', $vid, '=');
      if ($query_type == ' INNER ') {
        $query->innerJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      elseif ($query_type = ' LEFT ') {
        $query->leftJoin('taxonomy_index', 'ti', 't.tid = ti.tid');
      }
      else {
        debug('Join type should be LEFT or INNER, but something else got passed instead.');
      }
      if ($total_terms[0] >= 1) {
        $query->range(0, $total_terms[0]);
      }      //$query = "SELECT t.name AS name FROM {taxonomy_term_data} t $query_type JOIN {taxonomy_index} tn ON (t.tid = tn.tid) WHERE t.vid = $vid GROUP BY t.name ORDER BY t.name";
      break;
  }
  // Run the query
  $result = $query->execute();
  $terms = array();
  $selected = FALSE;
  foreach ($result as $record) {
  $query_result[] = $record->name;
    if (is_array($selected_terms) && in_array($record->name, $selected_terms)) {
      $selected = TRUE;
    }
    $variables = array(
      'name' => check_plain($record->name),
      'selected' => $selected,
    );
    $theme_output = theme('suggestedterm', $variables);
    $terms[] = $theme_output;
    $selected = FALSE;
  }
  // Turn that big array of terms into a string for output and send it back to the calling function.
  $terms_markup = '<div class="suggestedterms">' . implode(', ', $terms) . '</div>';
  return $terms_markup;
}

/*
 * Implementation of hook_field_widget_WIDGET_TYPE_form_alter().
 */
function suggestedterms_field_widget_taxonomy_autocomplete_form_alter(&$element, &$form_state, $context) {
  $used_tids = array();
  foreach ($context['items'] as $item) {
    $used_tids[] = $item['tid'];
  }
  $selected_terms = '';
  $used_terms = taxonomy_term_load_multiple($used_tids);
  foreach($used_terms as $used_term) {
    if (!empty($selected_terms)) {
      $selected_terms .= ', ';
    }
    $selected_terms .= $used_term->name;
  }
  $display_what = variable_get('suggestedterms_display_mode', SUGGESTEDTERMS_DISPLAY_ALL);
  // If multiple vocabularies, loop over each.
  foreach ($context['field']['settings']['allowed_values'] as $key => $value) {

    $sort_order = variable_get('suggestedterms_sort_order', SUGGESTEDTERMS_SORT_NAME);
     switch ($sort_order) {
       case SUGGESTEDTERMS_SORT_POPULAR:
         $tag_description = t('Most popular terms');
         break;

       case SUGGESTEDTERMS_SORT_RECENT:
         $tag_description = t('Recently added');
         break;

       case SUGGESTEDTERMS_SORT_WEIGHT:
         $tag_description = t('Terms by Weight');
         break;

       case SUGGESTEDTERMS_SORT_USED:
         $tag_description = t('Recently Used');
         break;

       default:
         $tag_description = t('Terms by name');
         break;
    }


    // We have to get the vocab IDs from vocab names
    $vocabulary = db_select('taxonomy_vocabulary', 'tv')
        ->fields('tv')
        ->condition('machine_name', $value['vocabulary'], '=')
        ->execute()
        ->fetchAssoc();
    $vid = $vocabulary['vid'];
    // Build the suggested terms and set in description tag.
    $terms_list_markup = $tag_description . ': ' . _suggestedterms_build_suggestions($vid, $sort_order, $display_what, explode(', ', $selected_terms));
    // If the user has checked the "fieldset" box in settings, make a fieldset.
    $display_fieldset = variable_get('suggestedterms_display_fieldset', SUGGESTEDTERMS_DISPLAY_FIELDSET);
    if ($display_fieldset == TRUE ) {
      $fieldset_variables['element'] = array(
        '#id' => 'suggestedterms_widget_list',
        '#children' => NULL,
        '#theme' => 'fieldset',
        '#title' => 'Tags:',
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#attached' => array(
          'js' => array(
            'misc/form.js',
            'misc/collapse.js',
          ),
        ),
        '#attributes' => array(
          'class' => array('collapsible', 'collapsed'),
        ),
        '#value' => $terms_list_markup,
      );
      $fieldset = theme_fieldset($fieldset_variables);
      $element['#description'] .= $fieldset;
    }
    // Otherwise just paste the list into the description directly.
    else {
      $element['#description'] .= "<br />\n" . $terms_list_markup;
    }
  }
}

/**
 * Administration page for suggested terms.
 */
function suggestedterms_admin() {

  $form['suggestedterms_maximum_displayed'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum number of links'),
    '#default_value' => variable_get('suggestedterms_maximum_displayed', 5),
    '#size' => 2,
    '#maxlength' => 2,
    '#description' => t('The maximum number of links to display in the block. Enter 0 to show all.'),
  );
  $form['suggestedterms_sort_order'] = array(
    '#type' => 'radios',
    '#title' => t('Link sort order'),
    '#default_value' => variable_get('suggestedterms_sort_order', SUGGESTEDTERMS_SORT_NAME),
    '#description' => t("The sort order for the links displayed."),
    '#options' => array(
      SUGGESTEDTERMS_SORT_POPULAR => t('Most used'),
      SUGGESTEDTERMS_SORT_NAME => t('Alphabetically'),
      SUGGESTEDTERMS_SORT_WEIGHT => t('Weight'),
      SUGGESTEDTERMS_SORT_RECENT => t('Most recently added'),
      SUGGESTEDTERMS_SORT_USED => t('Most recently used'),
     ),
  );
  $form['suggestedterms_display_mode'] = array(
    '#type' => 'radios',
    '#title' => t('Which terms to display'),
    '#default_value' => variable_get('suggestedterms_display_mode', SUGGESTEDTERMS_DISPLAY_ALL),
    '#description' => t("Whether to display all defined terms or only the ones previously used."),
    '#options' => array(
       SUGGESTEDTERMS_DISPLAY_USED => t('Previously-used terms'),
       SUGGESTEDTERMS_DISPLAY_ALL => t('All terms'),
    ),
  );
  $form['suggestedterms_display_fieldset'] = array(
    '#type' => 'checkbox',
    '#prefix' => '<h4>Display Options</h4>',
    '#title' => t('Display the terms in a collapsed fieldset'),
    '#default_value' => variable_get('suggestedterms_display_fieldset', SUGGESTEDTERMS_DISPLAY_FIELDSET),
    '#description' => t('The terms will be wrapped in a fieldset that is collapsed by default'),
  );

  return system_settings_form($form);
}

/**
 * Implementation of hook_menu().
 */
function suggestedterms_menu() {

  $items = array();

  $items['admin/config/content/suggestedterms'] = array(
    'title' => 'Suggested terms',
    'description' => 'Provide integrated suggestions of recent or popular tags from the given vocabulary.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('suggestedterms_admin'),
    'access arguments' => array('administer suggested terms configuration'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}